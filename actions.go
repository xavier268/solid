package solid

// ForceAction represents a force with its point of application.
// This structure allows for precise control over where forces are applied on the rigid body.
type ForceAction struct {
	Force Vect // Force vector in local or global coordinates [N]
	Point Vect // Point of application relative to COM (Vect{0,0,0} = center of mass) [m]
	// Always in local coordinates regardless of IsLocal flag
	IsLocal bool // true = force in local coordinates, false = global coordinates
}

// TorqueAction represents a pure torque (couple) applied to the rigid body.
// Torques cause rotation without translation since they have no specific point of application.
type TorqueAction struct {
	Torque  Vect // Torque vector in local or global coordinates [NÂ·m]
	IsLocal bool // true = torque in local coordinates, false = global coordinates
}

// MultipleActions groups all forces and torques to be applied simultaneously.
// This allows for efficient batch processing of multiple actions in a single time step,
// which is more accurate than applying them sequentially.
type MultipleActions struct {
	Forces  []ForceAction  // List of forces to apply
	Torques []TorqueAction // List of torques to apply
}

// ApplyMultipleActions simultaneously applies all forces and torques defined in actions.
// This method is more accurate than applying forces sequentially because it calculates
// the net effect of all actions before integrating the motion equations.
//
// The algorithm:
// 1. Accumulates all forces into a net global force
// 2. Accumulates all torques (including those generated by off-center forces) into a net local torque
// 3. Applies the net force and torque in a single integration step
//
// This approach avoids coupling errors that would arise from sequential application.
//
// Parameters:
//
//	actions: Collection of forces and torques to apply
//	dt: Time step for integration [s]
func (s *Solid) ApplyMultipleActions(actions MultipleActions, dt float64) {
	// Accumulators for net effects
	totalGlobalForce := Vect{0, 0, 0} // Net force in global coordinates
	totalLocalTorque := Vect{0, 0, 0} // Net torque in local coordinates

	// 1. Process all forces and their induced torques
	for _, forceApp := range actions.Forces {
		if forceApp.IsLocal {
			// Force specified in local coordinates
			globalForce := s.Orientation.RotateVec(forceApp.Force)
			totalGlobalForce = totalGlobalForce.Add(globalForce)

			// Compute torque if force is applied off-center
			if forceApp.Point.NormSq() > 1e-20 { // Non-zero application point
				leverArm := s.Orientation.RotateVec(forceApp.Point)
				globalTorque := leverArm.CrossProduct(globalForce)
				localTorque := s.Orientation.Conj().RotateVec(globalTorque)
				totalLocalTorque = totalLocalTorque.Add(localTorque)
			}
		} else {
			// Force specified in global coordinates
			totalGlobalForce = totalGlobalForce.Add(forceApp.Force)

			// Compute torque if force is applied off-center
			if forceApp.Point.NormSq() > 1e-20 { // Non-zero application point
				// NOTE: Point is always in local coordinates, transform to global
				globalPoint := s.Orientation.RotateVec(forceApp.Point)
				leverArm := globalPoint // Already relative to COM
				globalTorque := leverArm.CrossProduct(forceApp.Force)
				localTorque := s.Orientation.Conj().RotateVec(globalTorque)
				totalLocalTorque = totalLocalTorque.Add(localTorque)
			}
		}
	}

	// 2. Process all pure torques
	for _, torqueApp := range actions.Torques {
		if torqueApp.IsLocal {
			// Torque already in local coordinates
			totalLocalTorque = totalLocalTorque.Add(torqueApp.Torque)
		} else {
			// Convert global torque to local coordinates
			localTorque := s.Orientation.Conj().RotateVec(torqueApp.Torque)
			totalLocalTorque = totalLocalTorque.Add(localTorque)
		}
	}

	// 3. Apply net effects using existing optimized methods
	// Translation from net force
	if totalGlobalForce.NormSq() > 1e-20 && s.Mass > 1e-10 {
		acceleration := totalGlobalForce.Scale(1.0 / s.Mass)
		s.Speed = s.Speed.Add(acceleration.Scale(dt))
		s.Position = s.Position.Add(s.Speed.Scale(dt))
	}

	// Rotation from net torque (includes gyroscopic effects)
	if totalLocalTorque.NormSq() > 1e-20 {
		s.ApplyLocalTorque(totalLocalTorque, dt)
	}
}
